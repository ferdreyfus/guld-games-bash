#!/bin/bash
#MIT License
#
#Copyright (c) 2016 gitguild
#Copyright (c) 2018 Zimmi S.A.
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.

VERSION=0.0.1

ORIG_IFS=$IFS

# Save $0 so we can shift
# $1 must be a cmd.
export PROG_NAME=$( echo "$0" | grep -o "[^/]*$" )
export COMMAND=$1

# Git user configuration is a pre-requisite of this script.
export USER_NAME=$( git config user.username )
export USER_EMAIL=$( git config user.email )
export USER_SIGNINGKEY=$( git config user.signingkey )
USER_IS_CONFIGURED=true

# gitolite user home, where repos are hosted
# shellcheck disable=SC2116
export GIT_HOME=$(echo ~git)

# default working directory, where games are found!
# TODO iup
if [ "$GULD_HOME" = "" ]; then
  export GG_DIR=$HOME"/ledger/GG"
  export GULD_DIR=$HOME"/ledger/GULD"
  export PRICE_DIR=$HOME"/ledger/prices"
else
  export GG_DIR=$GULD_HOME"/ledger/GG"
  export GULD_DIR=$GULD_HOME"/ledger/GULD"
  export PRICE_DIR=$GULD_HOME"/ledger/prices"
fi
if [ -d "$GG_DIR" ]; then
  cd "$GG_DIR"
fi

# detect OS
MYOS=$( uname )
if [ $MYOS != "Linux" ] && [ $MYOS != "Darwin" ] ; then
  echo "only Linux and Darwin (macOS) are supported"
  exit 1
fi

#------------------------CLI Helpers--------------------------
USAGE_PREAMBLE="
  $PROG_NAME  Play guld games

  Usage:
"
GENERAL_USAGE="    $PROG_NAME help    Show the general help.
    $PROG_NAME version  Show the program version.

  Options:
"

USAGE_SUFFIX="    $PROG_NAME <cmd> -h  Show command help details."

command_usage_line() {
  printf "    %s %s  %s" "$PROG_NAME" "$COMMAND" "$*"
}
subcommand_usage_line() {
  SUBCMD=$1
  shift
  printf "    %s %s  %s  %s" "$PROG_NAME" "$COMMAND" "$SUBCMD" "$*"
}
# $1 the arg string
# $2 the help
command_option_line() {
  OPTSTR=$1
  shift
  printf "    %s    %s" "$OPTSTR" "$*"
}


#------------------------CLI Handlers-----------------------------

# The main handler. Takes raw user input from command line.
# $1 is the command, $2 is the first argument to the command.
__main() {
  case "$1:$2" in
    new:-h)
      COMMAND=$1
      cmdl="$( command_usage_line \<game-name\> \<max\> \<bet\> Creates a new game. )"
      echo $cmdl
      printf "\n%s" "Command-line arguments:"
      printf "\n%s\n\n" "  game-name: must be a unique name."
      printf "%s\n" "  max: generates a random number in the range of (0-max), inclusive."
      printf "%s\n\n" "       Must be an integer, 1 or greater."
      printf "%s\n" "  bet: the size of the wager."
      printf "%s\n" "       As the game creator (dealer), you deposit (max * bet) to the contract."
      ;;
    guess:-h)
      COMMAND=$1
      cmdl="$( command_usage_line \<game-name\> \<guess\> Guess the number for a game. )"
      echo $cmdl
      printf "\n%s" "Command-line arguments:"
      printf "\n%s\n\n" "  game-name: must be a unique name."
      printf "%s\n" "  guess: your guess at the value of the game's secret number."
      printf "%s\n" "         Must be an integer between 0 and the maximum for the game, inclusive."
      ;;
    new:*)
      shift
      handle_new_cmd "$@"
      ;;
    guess:*)
      shift
      handle_guess_cmd "$@"
      ;;
    version:*)
      echo $VERSION
      ;;
    price:*)
      shift
      handle_price_cmd "$@"
      ;;
    bal:*)
      shift
      handle_bal_cmd "$@"
      ;;
    stake:*)
      shift
      handle_stake_cmd "$@"
      ;;

#    reveal:*)
#      shift
#      handle_reveal_cmd "$@"
#      ;;
#    audit:*)
#      shift
#      handle_audit_cmd "$@"
#      ;;
#    ledger:*)
#      shift
#      handle_ledger_cmd "$@"
#      ;;
    *:*)
      COMMAND="new"
      cmdl="$( command_usage_line \<game-name\> \<max\> \<bet\> Create a new game. )
"
      COMMAND="guess"
      cmdl="$cmdl$( command_usage_line \<game-name\> \[guess\] Guess the number for a game. )
"
      COMMAND="price"
      cmdl="$cmdl$( command_usage_line Number of GG received per 1 GULD burn contract. )
"
      COMMAND="bal"
      cmdl="$cmdl$( command_usage_line [user] gg group balance for [user] or whole group. )
"
      COMMAND="stake"
      cmdl="$cmdl$( command_usage_line [game] Stake for game, if you are the winner. )
"
#       COMMAND="reveal"
#       cmdl="$cmdl$( command_usage_line Reveal answer and end the game. )
# "
#       COMMAND="audit"
#       cmdl="$cmdl$( subcommand_usage_line Audit a game\'s results. )
# "
      echo "$USAGE_PREAMBLE$cmdl$GENERAL_USAGE$USAGE_SUFFIX"
      exit
      ;;
  esac
}

handle_new_cmd() {
  pulled=$( git pull origin master 2>&1 )
  if [ "$1" != "" ] ; then
    GINSTANCE=$1
    if [ -d "LOTTERY/$GINSTANCE" ] ; then
      echo "Game $GINSTANCE already exists. Pick another name."
      exit
    else
      mkdir "LOTTERY/$GINSTANCE"
      cd "LOTTERY/$GINSTANCE"
    fi
  else
    cmdl="$( subcommand_usage_line new \<game-name\> \<max\> \<bet\> Create a new game. )\n"
    echo "$USAGE_PREAMBLE$cmdl$GENERAL_USAGE$USAGE_SUFFIX"
    exit
  fi
  if [[ $2 =~ ^[0-9]+$ ]] ; then
    MMAX=$(($2>65535?65535:$2))
    MAX=$(($MMAX<1?1:$MMAX))
  else
    echo "error: Max $2 not a number" >&2
    exit 1
  fi
  if ! [[ $3 =~ ^[0-9]+[.]{0,1}[0-9]+$ ]] ; then
    echo "error: Bet not a number" >&2; exit 1
  else
    BET=$3
    GGBET=$( bc <<< "scale=8; $BET*$MAX" | sed 's/^\./0./' )
    GG_GULD_RATE=$( handle_price_cmd )
    GULDBETF=$( bc <<< "scale=8; $GGBET/$GG_GULD_RATE" | sed 's/^\./0./' )
    # round up to nearest GULD bit
    if [ ${GULDBETF:1:2} = "." ] && ! [ ${GULDBETF:8:9} -eq "0" ] ; then
      GULDBET=$( printf "%.8f\n" $( bc <<< scale=8; $GULDBETF + 0.000000005 ) | bc | sed 's/^\./0./' )
    else
      GULDBET=$( printf "%.8f\n" $GULDBETF | bc | sed 's/^\./0./' )
    fi
  fi
  EPOCH_TIME=$( date -u +%s )
  TDATE=$( date -u +%Y/%m/%d )
  if [ $MYOS = "Linux" ] ; then
    SECRET=$( shuf -i 0-$MAX -n 1 )
  elif [ $MYOS = "Darwin" ] ; then
    SECRET=$( gshuf -i 0-$MAX -n 1 )
  fi
  FUNDING=$"$TDATE * GG LOTTERY $GINSTANCE FUNDING
    ; timestamp: $EPOCH_TIME
    guld:Income:register:group:gg:$USER_NAME    $GULDBET GULD
    guld:Income:register:group:gg    -$GULDBET GULD
    gg:Games:LOTTERY:$GINSTANCE   $GGBET GG
    gg:Liabilities    -$GGBET GG"
  echo "$FUNDING"
  echo $USER_NAME > DEALER.txt
  pulled=$( git add DEALER.txt 2>&1 )
  echo $BET > BET.txt
  pulled=$( git add BET.txt 2>&1 )
  echo $MAX > MAX.txt
  pulled=$( git add MAX.txt 2>&1 )
  echo "$FUNDING" > "$EPOCH_TIME.dat"
  pulled=$( git add "$EPOCH_TIME.dat" 2>&1 )
  printf "%s" "$SECRET" > SECRET.txt
  signum=$(printf "%s:%s:%s" "$GINSTANCE" "$MAX" "$SECRET" | gpg2 -u $USER_SIGNINGKEY --clearsign 2>/dev/null )
  printf "%s" "$signum" > signum.asc
  if [ $MYOS = "Linux" ] ; then
    hashnum=$(printf "%s" "$signum" | sha512sum | tr -d -)
  elif [ $MYOS = "Darwin" ] ; then
    hashnum=$(printf "%s" "$signum" | shasum -a 512 | tr -d -)
  fi
  echo $hashnum > hashnum.txt
  pulled=$( git add hashnum.txt 2>&1 )
  pulled=$( git commit -m "new game" 2>&1 )
  pulled=$( git push origin master 2>&1 )
  end=$((SECONDS+18000)) # 30 minutes
  while [ $SECONDS -lt $end ]; do
    pulled=$( git pull origin master 2>&1 )
    if [ -f guess.asc ] ; then
      cd "$GG_DIR"
      handle_reveal_cmd $GINSTANCE
      break
    else
      sleep 5
    fi
  done
}

# $1 is now sub-command (build, check)
handle_guess_cmd() {
  pulled=$( git pull origin master 2>&1 )
  if [ "$1" != "" ] ; then
    GINSTANCE=$1
    if ! [ -d "$GG_DIR/LOTTERY/$GINSTANCE" ] ; then
      echo "Game $GINSTANCE does not exist. Pick an open game."
      exit
    else
      cd "LOTTERY/$GINSTANCE"
    fi
  else
    cmdl="$( subcommand_usage_line guess \<game-name\> \[guess\] Guess the number for a game )\n"
    echo "$USAGE_PREAMBLE$cmdl$GENERAL_USAGE$USAGE_SUFFIX"
    exit
  fi

  DEALER=$( cat DEALER.txt )
  if [ $DEALER = $USER_NAME ] ; then
    echo "Cannot guess for your own game."
    exit 1
  fi

  if [ -f PLAYER.txt ] || [ -f guess.asc ] ; then
    echo "This game is not open for more players."
    exit 1
  fi

  BET=$( cat BET.txt )
  MAX=$( cat MAX.txt )

  if [[ $2 =~ ^[0-9]+$ ]] ; then
    MGUESS=$(($2>$MAX?$MAX:$2))
    GUESS=$(($MGUESS<0?0:$MGUESS))
  else
    if [ $MYOS = "Linux" ] ; then
      GUESS=$( shuf -i 0-$MAX -n 1 )
    elif [ $MYOS = "Darwin" ] ; then
      GUESS=$( gshuf -i 0-$MAX -n 1 )
    fi
  fi
  GG_GULD_RATE=$( handle_price_cmd )
  GULDBETF=$( bc <<< "scale=8; $BET/$GG_GULD_RATE" | sed 's/^\./0./' )
  # round up to nearest GULD bit
  if [ ${GULDBETF:1:2} = "." ] && ! [ ${GULDBETF:8:9} = "0" ] ; then
    GULDBET=$( printf "%.8f\n" $( bc <<< scale=8; $GULDBETF + 0.000000005 ) | bc | sed 's/^\./0./' )
  else
    GULDBET=$( printf "%.8f\n" "$GULDBETF" | bc | sed 's/^\./0./' )
  fi
  echo $USER_NAME > PLAYER.txt
  pulled=$( git add PLAYER.txt 2>&1 )

  EPOCH_TIME=$( date -u +%s )
  TDATE=$( date -u +%Y/%m/%d )
  FUNDING=$"$TDATE * GG LOTTERY $GINSTANCE FUNDING
    ; timestamp: $EPOCH_TIME
    guld:Income:register:group:gg:$USER_NAME    $GULDBET GULD
    guld:Income:register:group:gg    -$GULDBET GULD
    gg:Games:LOTTERY:$GINSTANCE   $BET GG
    gg:Liabilities    -$BET GG"
  echo "$FUNDING"
  echo "$FUNDING" > "$EPOCH_TIME.dat"
  pulled=$( git add "$EPOCH_TIME.dat"  2>&1 )
  siguess=$(printf "%s:%s:%s" "$GINSTANCE" "$MAX" "$GUESS" | gpg2 -u $USER_SIGNINGKEY --clearsign  2>/dev/null )
  printf "%s" "$siguess" > guess.asc
  pulled=$( git add guess.asc 2>&1 )
  pulled=$( git commit -m "guess" 2>&1 )
  pulled=$( git push origin master 2>&1 )
  end=$((SECONDS+18000)) # 30 minutes
  while [ $SECONDS -lt $end ]; do
    pulled=$( git pull origin master 2>&1 )
    if [ -f "guess" ] ; then
      GUESS=$( cat guess )
      SECRET=$( cat SECRET.txt )
      ANSWER=$( printf "%s:%s:%s" "$GINSTANCE" "$MAX" "$SECRET" )
      if [ "$GUESS" = "" ] ; then
        echo "invalid guess"
        exit
      elif [ "$GUESS" = "$ANSWER" ] ; then
        echo "You won!"
        WINNER=$PLAYER
        handle_stake_cmd $GINSTANCE
      else
        echo "You lost."
        WINNER=$DEALER
      fi
      break
    else
      sleep 5
    fi
  done
}

# $1 is now sub-command
# $@ are params for the sub-command
handle_reveal_cmd() {
  pulled=$( git pull origin master 2>&1 )

  if [ "$1" != "" ] ; then
    GINSTANCE=$1
    if ! [ -d "$GG_DIR/LOTTERY/$GINSTANCE" ] ; then
      echo "Game $GINSTANCE does not exist. Pick an open game."
      exit
    else
      cd "LOTTERY/$GINSTANCE"
    fi
  else
    cmdl="$( subcommand_usage_line reveal Reveal answer and end the game. )
"
    echo "$USAGE_PREAMBLE$cmdl$GENERAL_USAGE$USAGE_SUFFIX"
    exit
  fi

  BET=$( cat BET.txt )
  MAX=$( cat MAX.txt )
  WINNINGS=$( bc <<< "scale=8; $BET*($MAX+1)" | sed 's/^\./0./' )
  DEALER=$( cat DEALER.txt )
  PLAYER=$( cat PLAYER.txt )
  VERIFIED=$( gpg2 --status-fd --verify guess.asc 2>/dev/null )
  GUESS=$( cat guess )
  SECRET=$( cat SECRET.txt )
  ANSWER=$( printf "%s:%s:%s" "$GINSTANCE" "$MAX" "$SECRET" )
  if [ "$GUESS" = "" ] ; then
    echo "invalid guess"
    exit
  elif [ "$GUESS" = "$ANSWER" ] ; then
    echo "You lost."
    WINNER=$PLAYER
  else
    echo "You won!"
    WINNER=$DEALER
  fi

  EPOCH_TIME=$( date -u +%s )
  TDATE=$( date -u +%Y/%m/%d )
  CLAIM=$"$TDATE * GG LOTTERY $GINSTANCE CLAIM
    ; timestamp: $EPOCH_TIME
    gg:Games:LOTTERY:$GINSTANCE    -$WINNINGS GG
    gg:Games:LOTTERY:$GINSTANCE:$WINNER    $WINNINGS GG"
  echo "$CLAIM"
  echo "$CLAIM" > "$EPOCH_TIME.dat"
  pulled=$( git add "$EPOCH_TIME.dat" 2>&1 )

  pulled=$( git add SECRET.txt signum.asc guess 2>&1 )
  pulled=$( git commit -m "reveal" 2>&1 )
  if [ $WINNER = $USER_NAME ] ; then
    handle_stake_cmd $GINSTANCE
  else
    pulled=$( git push origin master 2>&1 )
  fi
}

# $1 is now sub-command
# $@ are params for the sub-command
handle_stake_cmd() {
  pulled=$( git pull origin master 2>&1 )

  if [ "$1" != "" ] ; then
    GINSTANCE=$1
    if ! [ -d "$GG_DIR/LOTTERY/$GINSTANCE" ] ; then
      echo "Game $GINSTANCE does not exist. Pick an open game."
      exit
    else
      cd "LOTTERY/$GINSTANCE"
    fi
  else
    cmdl="$( subcommand_usage_line \<game\> Stake maximum amount allowable per game. )
"
    echo "$USAGE_PREAMBLE$cmdl$GENERAL_USAGE$USAGE_SUFFIX"
    exit
  fi

  BET=$( cat BET.txt )
  MAX=$( cat MAX.txt )
  DEALER=$( cat DEALER.txt )
  PLAYER=$( cat PLAYER.txt )
  GUESS=$( cat guess )
  SECRET=$( cat SECRET.txt )
  ANSWER=$( printf "%s:%s:%s" "$GINSTANCE" "$MAX" "$SECRET" )
  if [ "$GUESS" = "" ] ; then
    echo "invalid guess"
    exit
  elif [ "$GUESS" = "$ANSWER" ] ; then
    WINNER=$PLAYER
  else
    WINNER=$DEALER
  fi
  if [ "$USER_NAME" != "$WINNER" ] ; then
    echo "you are not the winner"
    exit
  fi
  STAKED=$( cat *.dat | ledger -f - equity gg:Equity:$WINNER | grep gg: | grep -o "[0-9.,]*" )
  if [ ! "$STAKED" == "" ] ; then
    echo "already staked this game"
    exit
  fi

  EPOCH_TIME=$( date -u +%s )
  TDATE=$( date -u +%Y/%m/%d )
  STAKE=$"$TDATE * GG LOTTERY $GINSTANCE STAKE
    ; timestamp: $EPOCH_TIME
    gg:Games:LOTTERY:$GINSTANCE:$WINNER    -$BET GG
    gg:Equity:$WINNER    $BET GG"

  echo "$STAKE"
  echo "$STAKE" > "$EPOCH_TIME.dat"
  pulled=$( git add "$EPOCH_TIME.dat" 2>&1 )

  pulled=$( git commit -m "stake" 2>&1 )
  pulled=$( git push origin master 2>&1 )
}

# $1 is now sub-command
# $@ are params for the sub-command
handle_price_cmd() {
  year=$( date -u +%Y )
  month=$( date -u +%m )
  day=$( date -u +%d )
  price=7100
  while read p; do
    if [[ $p =~ ^P.*GG$ ]] ; then
      tyear=${p:1:5}
      tmonth=${p:7:2}
      tday=${p:10:2}
      if [[ $tyear -le $year ]] && [[ $tmonth -le $month ]] && [[ $tday < $day ]] ; then
        if [[ $p =~ [0-9.]*[[:space:]]+GG$ ]] ; then
          price=$( echo ${BASH_REMATCH[0]} | grep -o [0-9.]* )
        fi
      else
        break
      fi
    fi
  done < "$PRICE_DIR/gg.db"
  echo $price
}

# $1 is now sub-command
# $@ are params for the sub-command
handle_bal_cmd() {
  pulled=$( git pull origin master 2>&1 )

  if [ "$1" == "" ] ; then
    usearch=".*"
  else
    usearch=":$1"
  fi
  eqtx=$( find ~/ledger -name '*.d*' | grep "\.d[bat]*$" | while read line ; do echo include $line ; done | ledger -f - equity ^.*:gg$usearch$ ^gg:.*$usearch$ )
  # printf "%s\n" "$eqtx"
  if [ ! "$1" == "" ] ; then
    GG_TOTAL_INV=$( printf "%s" "$eqtx" | grep "^ *Equity:Opening Balances.*GG$" | grep -o [0-9\.\,-]* )
    GG_TOTAL_INV=$( echo "${GG_TOTAL_INV/,/}" )
    GG_TOTAL=$( bc <<< "scale=8; $GG_TOTAL_INV*-1" )
    GULD_TOTAL=$( printf "%s" "$eqtx" | grep "^ *Equity:Opening Balances.*GULD$" | grep -o [0-9\.\,-]* )
  else
    GG_TOTAL=0
    GULD_TOTAL=$( printf "%s" "$eqtx" | grep "^ *Equity:Opening Balances.*GULD$" | grep -o [0-9\.\,-]* )
  fi
  ggaccounts=$( printf "%s" "$eqtx" | grep gg:[EG][qa] )
  guldaccounts=$( printf "%s" "$eqtx" | grep :gg: )
  printf "%s\n%s\n---------------\n" "$ggaccounts" "$guldaccounts"
  printf "%s GG\n%s GULD\n" "$GG_TOTAL" "$GULD_TOTAL"
}

#-------------------user prep and command section--------------------------

gpgkeygen() {
  echo "The gpg2 --gen-key walk-through is about to be run."
  echo "For GitGuild to function, a dual key (RSA and RSA or DSA and Elgamal)"
  echo "is required. Other parameters (name, email) should match your"
  echo "git identity."
  echo
  echo "It is highly recommended to create a passphrase for your security!"
  echo "Your passphrase is what stops someone using your machine"
  echo "from stealing your identity."
  echo "Use a strong password, back it up and create a revocation key."
  echo
  echo "The developers recommend using a free and open source password manager."
  echo "The pass program is used internally, and if you like the command line,"
  echo "it could be for you even outside of gitguild."
  echo ""
  echo "OK, ready to generate keys?"
  read readyono
  echo
  if [ "$( echo "$readyono" | grep '[yY].*' )" != "" ]; then
      gpg2 --gen-key
  else
    user_cfg_error "signingkey" "gpg2 key id"
  fi
}

# $1 is the official git config format
# $2 is the user understandable format
user_cfg_error() {
  echo "OK, to try setting your git $1 at any time, run:" 1>&2
  echo 1>&2
  echo "gitguild user status" 1>&2
  USER_IS_CONFIGURED=false
}

# $1 is the username to search for
guess_cfg_from_authors_by_value() {
  if [ -f ./AUTHORS ]; then
    cfginfo=$( grep "$1" ./AUTHORS )
    if [ "$cfginfo" != "" ]; then
      USER_NAME="$( echo "$cfginfo" | grep -o '^[^ ]*')"
      git config --global --add user.email "$USER_EMAIL"
      USER_EMAIL="$( echo "$cfginfo" | grep -o ' [^ ]* ' | tr -d ' ' )"
      git config --global --add user.email "$USER_EMAIL"
      USER_SIGNINGKEY="$( echo "$cfginfo" | grep -o '[^ ]*$' )"
      git config --global --add user.signingkey "$USER_SIGNINGKEY"
    fi
  fi
}

print_sig_guesses() {
  if [ "$USER_EMAIL" != "" ]; then
    keylist=$( gpg2 --list-secret-keys --fast-list-mode "$USER_EMAIL" | grep sec | \
      grep -o "[A-Z0-9]\{8\} " )
  elif [ "$USER_NAME" != "" ]; then
    keylist=$( gpg2 --list-secret-keys --fast-list-mode "$USER_NAME" | grep sec | \
      grep -o "[A-Z0-9]\{8\} " )
  fi
  if [ "$keylist" != "" ]; then
    echo "Detected one or more keys matching your name or email."
    echo "The one you want is probably among these."
    echo "$keylist"
    echo
  elif [ "$USER_EMAIL" != "" ] && [ "$USER_NAME" != "" ]; then
    echo "Could not detect a key matching your name or email."
    echo
    gpgkeygen
  fi
}

# $1 the git config name of the field
get_cfg_by_name() {
  case $1 in
    name)
      echo "$USER_NAME"
      ;;
    email)
      echo "$USER_EMAIL"
      ;;
    signingkey)
      echo "$USER_SIGNINGKEY"
      ;;
  esac
}

# $1 the git config name of the field
# $2 the value to set
set_cfg_by_name() {
  case $1 in
    name)
      USER_NAME=$2
      ;;
    email)
      USER_EMAIL=$2
      ;;
    signingkey)
      USER_SIGNINGKEY=$2
      ;;
  esac
}

# $1 is the official git config format of the field name
# $2 is the user understandable format
get_or_set_cfg_value() {
  if [ "$( get_cfg_by_name "$1" )" = "" ]; then
    echo "WARNING: Git user.$1 not configured."
    echo
    if [ "$1" != "name" ] && [ "$( get_cfg_by_name "$1" )" = "" ]; then
      # try to guess based on name
      echo "guessing"
      guess_cfg_from_authors_by_value "$USER_NAME"
    fi
    if [ "$( get_cfg_by_name "$1" )" = "" ] && [ "$1" = "signingkey" ]; then
      print_sig_guesses
    elif [ "$1" = "signingkey" ]; then
      return
    fi
    if [ "$( get_cfg_by_name "$1" )" = "" ]; then
      echo "Please enter your git $1 followed by [ENTER]"
      read userval
      if [ "$userval" != "" ]; then
        git config --global --add user."$1" "$userval"
        echo
        set_cfg_by_name "$1" "$userval"
      else
        user_cfg_error "$2" "$3"
      fi
    fi
  fi
}

get_or_set_all_cfg_values() {
  get_or_set_cfg_value "name" "user name"
  get_or_set_cfg_value "email" "email"
  get_or_set_cfg_value "signingkey" "gpg2 key id"
  git config --global commit.gpgsign true
}


#---------------tx (transaction) section----------------
# Functions and handlers related to building, checking,
# and managing transactions.

# $1 remote name to check
use_gitolite_push() {
  if [ "$( git remote get-url "$1" | grep \"file://\")" != "" ] && [ "$USE_GITOLITE" = "true" ]; then
    echo 1
  else
    echo 0
  fi
}

__main "$@"
